<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Radian Visualizer with Axes</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background-color: #000;
            color: #fff;
            font-family: 'Arial', sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            box-sizing: border-box;
            background: radial-gradient(ellipse at center, #0a0e24 0%, #000000 100%);
            overflow-x: hidden;
        }

        #main-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 800px;
        }

        #canvas-container {
            position: relative;
            width: min(85vw, 85vh, 650px);
            margin: 0 auto 20px;
            animation: canvasGlow 3s ease-in-out infinite;
        }

        canvas {
            width: 100%;
            height: auto;
            aspect-ratio: 1/1;
            border-radius: 50%;
            box-shadow: 0 0 40px rgba(0, 150, 255, 0.4);
            background: radial-gradient(ellipse at center, #0a0e24 0%, #000000 100%);
            display: block;
            cursor: pointer;
            touch-action: none;
        }

        #controls {
            width: 100%;
            max-width: 500px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
        }

        .slider-container {
            width: 100%;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #radian-slider {
            flex-grow: 1;
            -webkit-appearance: none;
            height: 8px;
            background: rgba(100, 100, 255, 0.3);
            border-radius: 10px;
            outline: none;
            transition: background 0.3s;
        }

        #radian-slider:hover {
            background: linear-gradient(to right, rgba(0, 200, 255, 0.3), rgba(0, 100, 200, 0.3));
        }

        #radian-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #00ccff;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 200, 255, 0.9);
            transition: transform 0.2s;
        }

        #radian-slider::-webkit-slider-thumb:active {
            transform: scale(1.2);
        }

        #radian-slider:focus {
            outline: 2px solid #00ccff;
        }

        .slider-value {
            min-width: 50px;
            text-align: center;
            font-size: clamp(14px, 2vw, 16px);
            font-weight: bold;
            color: #0ff;
        }

        .slider-tick-marks {
            width: 100%;
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
        }

        .tick-mark {
            width: 1px;
            height: 8px;
            background: rgba(100, 200, 255, 0.3);
            position: relative;
        }

        .tick-label {
            position: absolute;
            top: 12px;
            left: 50%;
            transform: translateX(-50%);
            font-size: clamp(10px, 1.5vw, 11px);
            color: #aaf;
            white-space: nowrap;
        }

        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 20, 40, 0.8);
            padding: 10px;
            border-radius: 10px;
            border: 1px solid rgba(0, 150, 255, 0.4);
            max-width: 200px;
            box-sizing: border-box;
            z-index: 5;
        }

        #info-panel h2 {
            margin-top: 0;
            color: #0cf;
            font-size: clamp(12px, 2vw, 14px);
            border-bottom: 1px solid rgba(0, 150, 255, 0.3);
            padding-bottom: 6px;
        }

        #angle-display {
            font-size: clamp(14px, 2vw, 16px);
            font-weight: bold;
            color: #0ff;
            margin: 8px 0;
        }

        #definition {
            font-size: clamp(10px, 1.8vw, 12px);
            line-height: 1.4;
            color: #aaf;
        }

        .formula, #arc-length-display, #key-angle-tooltip, #point-coordinates {
            font-size: clamp(10px, 1.8vw, 12px);
            font-weight: bold;
            color: #0ff;
            margin-top: 8px;
        }

        #key-angle-tooltip {
            color: #ff0;
            display: none;
        }

        .control-button {
            padding: 8px 16px;
            background: rgba(0, 100, 200, 0.5);
            border: 1px solid rgba(0, 150, 255, 0.3);
            border-radius: 5px;
            color: #fff;
            cursor: pointer;
            font-size: clamp(12px, 1.8vw, 14px);
            transition: background 0.3s;
        }

        .control-button:hover {
            background: rgba(0, 150, 255, 0.7);
        }

        .particle {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            transition: transform 0.1s;
        }

        #starfield {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }

        @keyframes canvasGlow {
            0%, 100% { box-shadow: 0 0 40px rgba(0, 150, 255, 0.4); }
            50% { box-shadow: 0 0 60px rgba(0, 150, 255, 0.6); }
        }

        @media (max-width: 600px) {
            body {
                padding: 15px;
            }
            #canvas-container {
                width: min(85vw, 85vh, 400px);
            }
            .slider-value {
                min-width: 40px;
            }
            #radian-slider::-webkit-slider-thumb {
                width: 16px;
                height: 16px;
            }
            #info-panel {
                max-width: 180px;
                padding: 8px;
                left: 50%;
                transform: translateX(-50%);
            }
            .control-button {
                padding: 6px 12px;
                font-size: clamp(10px, 1.5vw, 12px);
            }
        }
    </style>
</head>
<body>
    <div id="starfield"></div>
    <div id="main-container">
        <div id="canvas-container">
            <canvas id="radianCanvas" aria-label="Interactive radian visualization with coordinate axes"></canvas>
        </div>
        
        <div id="controls">
            <div class="slider-container">
                <span class="slider-value">0</span>
                <input type="range" id="radian-slider" min="0" max="6" step="0.1" value="0" 
                    aria-label="Radian angle slider" aria-valuemin="0" aria-valuemax="6" aria-valuenow="0">
                <span class="slider-value">2π</span>
            </div>
            
            <div class="slider-tick-marks">
                <div class="tick-mark"><span class="tick-label">0</span></div>
                <div class="tick-mark"><span class="tick-label">1</span></div>
                <div class="tick-mark"><span class="tick-label">2</span></div>
                <div class="tick-mark"><span class="tick-label">3</span></div>
                <div class="tick-mark"><span class="tick-label">π</span></div>
                <div class="tick-mark"><span class="tick-label">4</span></div>
                <div class="tick-mark"><span class="tick-label">5</span></div>
                <div class="tick-mark"><span class="tick-label">6</span></div>
            </div>
            <div style="display: flex; gap: 10px;">
                <button id="degree-toggle" class="control-button">Toggle Degrees</button>
                <button id="reset-btn" class="control-button">Reset</button>
            </div>
        </div>
        
        <div id="info-panel" role="region" aria-label="Radian information">
            <span class="sr-only">Radian visualization information including angle and coordinates</span>
            <h2>RADIAN DEFINITION</h2>
            <div id="angle-display">0.00 rad (0.00°)</div>
            <div id="definition">
                1 radian is the angle subtended by an arc whose length equals the radius of the circle.
                <br><br>
                <div class="formula">s = rθ</div> where:<br>
                • s = arc length<br>
                • r = radius<br>
                • θ = angle in radians
                <div id="arc-length-display">Arc Length: s = rθ (θ = 0.00 rad)</div>
                <div id="point-coordinates">Point: (x, y) = (0.00, 0.00)</div>
                <div id="key-angle-tooltip"></div>
            </div>
        </div>
    </div>

    <script>
        // Screen reader only styles
        const srStyle = document.createElement('style');
        srStyle.textContent = `.sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); border: 0; }`;
        document.head.appendChild(srStyle);

        // Create starfield background with layers and parallax
        function createStarfield() {
            const starfield = document.getElementById('starfield');
            const starConfigs = [
                { count: 60, size: 1.5, speed: 15, class: 'small-star' },
                { count: 20, size: 3, speed: 25, class: 'large-star' }
            ];
            const colors = ['#aaf', '#fff', '#0ff'];
            
            starConfigs.forEach(config => {
                for (let i = 0; i < config.count; i++) {
                    const star = document.createElement('div');
                    star.className = `particle ${config.class}`;
                    const size = Math.random() * config.size + 0.5;
                    const opacity = Math.random() * 0.5 + 0.3;
                    const x = Math.random() * 100;
                    const y = Math.random() * 100;
                    const duration = Math.random() * config.speed + 10;
                    const color = colors[Math.floor(Math.random() * colors.length)];
                    
                    star.style.width = `${size}px`;
                    star.style.height = `${size}px`;
                    star.style.left = `${x}%`;
                    star.style.top = `${y}%`;
                    star.style.opacity = opacity;
                    star.style.background = color;
                    star.style.animation = `twinkle ${duration}s infinite alternate`;
                    
                    starfield.appendChild(star);
                }
            });
            
            const style = document.createElement('style');
            style.textContent = `
                @keyframes twinkle {
                    0% { opacity: 0.3; }
                    100% { opacity: 0.8; }
                }
            `;
            document.head.appendChild(style);

            if (window.innerWidth > 600) {
                document.addEventListener('mousemove', (e) => {
                    const moveX = (e.clientX / window.innerWidth - 0.5) * 10;
                    const moveY = (e.clientY / window.innerHeight - 0.5) * 10;
                    document.querySelectorAll('.small-star').forEach(star => {
                        star.style.transform = `translate(${moveX * 0.5}px, ${moveY * 0.5}px)`;
                    });
                    document.querySelectorAll('.large-star').forEach(star => {
                        star.style.transform = `translate(${moveX}px, ${moveY}px)`;
                    });
                });
            }
        }

        // Main Radian Visualizer
        class RadianVisualizer {
            // Constants
            static MAX_ANGLE = 6;
            static EASING_FACTOR = 0.1;
            static KEY_ANGLES = {
                1: '1 rad',
                [Math.PI / 2]: 'π/2 rad',
                [Math.PI]: 'π rad',
                [2 * Math.PI]: '2π rad'
            };
            static TOLERANCE_RADIUS = 20;
            static AXIS_OPACITY = 0.3;
            static TICK_SIZE = 5;

            /**
             * @param {HTMLCanvasElement} canvas - The canvas element for visualization
             */
            constructor(canvas) {
                if (!canvas.getContext) {
                    console.error('Canvas not supported');
                    return;
                }
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.resizeCanvas();
                this.center = { x: this.canvas.width / 2, y: this.canvas.height / 2 };
                this.radius = Math.min(this.canvas.width, this.canvas.height) * 0.4;
                this.currentAngle = 0;
                this.targetAngle = 0;
                this.animationId = null;
                this.showDegrees = false;
                this.trailParticles = [];
                this.lastFrameTime = performance.now();
                this.slider = document.getElementById('radian-slider');
                this.sliderValues = document.querySelectorAll('.slider-value');
                this.debounceTimeout = null;
                this.previewAngle = null;
                
                this.init();
            }

            /** Resize the canvas based on container size */
            resizeCanvas() {
                const container = document.getElementById('canvas-container');
                const size = Math.min(container.offsetWidth, window.innerHeight * 0.7, 650);
                this.canvas.width = size;
                this.canvas.height = size;
                this.center = { x: this.canvas.width / 2, y: this.canvas.height / 2 };
                this.radius = size * 0.4;
            }

            /** Initialize event listeners and starfield */
            init() {
                this.setupEventListeners();
                createStarfield();
                this.animate();
                window.addEventListener('resize', () => {
                    this.resizeCanvas();
                    this.draw();
                });
                window.addEventListener('orientationchange', () => {
                    setTimeout(() => this.resizeCanvas(), 100);
                });
            }

            /** Set up all event listeners */
            setupEventListeners() {
                this.setupSlider();
                this.setupCanvas();
                this.setupControls();
            }

            /** Configure slider events with debouncing */
            setupSlider() {
                this.slider.addEventListener('input', (e) => {
                    clearTimeout(this.debounceTimeout);
                    this.debounceTimeout = setTimeout(() => {
                        const value = parseFloat(e.target.value);
                        this.targetAngle = value;
                        this.previewAngle = value;
                        this.slider.value = value;
                        this.slider.setAttribute('aria-valuenow', value.toFixed(1));
                        this.updateSliderDisplay();
                        this.animate();
                    }, 50);
                });
            }

            /** Configure canvas click and touch events */
            setupCanvas() {
                const handleAngleSet = (x, y) => {
                    const dx = x - this.center.x;
                    const dy = -(y - this.center.y);
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (Math.abs(distance - this.radius) > RadianVisualizer.TOLERANCE_RADIUS) return;
                    let angle = Math.atan2(dy, dx);
                    if (angle < 0) angle += 2 * Math.PI;
                    angle = Math.min(Math.max(angle, 0), RadianVisualizer.MAX_ANGLE);
                    this.targetAngle = angle;
                    this.slider.value = angle;
                    this.slider.setAttribute('aria-valuenow', angle.toFixed(1));
                    this.updateSliderDisplay();
                    this.animate();
                };

                this.canvas.addEventListener('click', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    handleAngleSet(e.clientX - rect.left, e.clientY - rect.top);
                });

                let touchStartAngle = 0;
                this.canvas.addEventListener('touchstart', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const touch = e.touches[0];
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;
                    const dx = x - this.center.x;
                    const dy = -(y - this.center.y);
                    touchStartAngle = Math.atan2(dy, dx);
                    if (touchStartAngle < 0) touchStartAngle += 2 * Math.PI;
                });

                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const rect = this.canvas.getBoundingClientRect();
                    const touch = e.touches[0];
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;
                    const dx = x - this.center.x;
                    const dy = -(y - this.center.y);
                    let angle = Math.atan2(dy, dx);
                    if (angle < 0) angle += 2 * Math.PI;
                    angle = Math.min(Math.max(angle, 0), RadianVisualizer.MAX_ANGLE);
                    this.targetAngle = angle;
                    this.previewAngle = angle;
                    this.slider.value = angle;
                    this.slider.setAttribute('aria-valuenow', angle.toFixed(1));
                    this.updateSliderDisplay();
                    this.animate();
                });
            }

            /** Configure control buttons and keyboard navigation */
            setupControls() {
                document.getElementById('degree-toggle').addEventListener('click', () => {
                    this.showDegrees = !this.showDegrees;
                    document.getElementById('degree-toggle').textContent = `Toggle ${this.showDegrees ? 'Radians' : 'Degrees'}`;
                    this.updateInfoDisplay();
                });

                document.getElementById('reset-btn').addEventListener('click', () => {
                    this.targetAngle = 0;
                    this.slider.value = 0;
                    this.slider.setAttribute('aria-valuenow', '0');
                    this.updateSliderDisplay();
                    this.animate();
                });

                document.addEventListener('keydown', (e) => {
                    if (e.target === this.slider) {
                        switch (e.key) {
                            case 'ArrowLeft':
                                e.preventDefault();
                                this.slider.value = Math.max(0, parseFloat(this.slider.value) - 1);
                                this.targetAngle = parseFloat(this.slider.value);
                                this.slider.setAttribute('aria-valuenow', this.targetAngle.toFixed(1));
                                this.updateSliderDisplay();
                                this.animate();
                                break;
                            case 'ArrowRight':
                                e.preventDefault();
                                this.slider.value = Math.min(RadianVisualizer.MAX_ANGLE, parseFloat(this.slider.value) + 1);
                                this.targetAngle = parseFloat(this.slider.value);
                                this.slider.setAttribute('aria-valuenow', this.targetAngle.toFixed(1));
                                this.updateSliderDisplay();
                                this.animate();
                                break;
                            case 'Enter':
                                this.animate();
                                break;
                        }
                    }
                });
            }

            /** Update slider display labels */
            updateSliderDisplay() {
                this.sliderValues[0].textContent = "0";
                this.sliderValues[1].textContent = "2π";
                if (Math.round(this.slider.value) === 3) {
                    this.sliderValues[1].textContent = "π";
                }
            }

            /**
             * Easing function for smooth transitions
             * @param {number} t - Progress (0 to 1)
             * @returns {number} Eased value
             */
            easeInOutQuad(t) {
                return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
            }

            /** Animate angle with easing and frame rate control */
            animateToAngle() {
                const now = performance.now();
                const deltaTime = (now - this.lastFrameTime) / 16.67;
                this.lastFrameTime = now;

                const diff = this.targetAngle - this.currentAngle;
                if (Math.abs(diff) > 0.01) {
                    const t = Math.min(1, RadianVisualizer.EASING_FACTOR * deltaTime);
                    this.currentAngle += diff * this.easeInOutQuad(t);
                    this.draw();
                    this.updateInfoDisplay();
                    this.animationId = requestAnimationFrame(() => this.animateToAngle());
                } else {
                    this.currentAngle = this.targetAngle;
                    this.previewAngle = null;
                    this.draw();
                    this.updateInfoDisplay();
                }
            }

            /** Update info panel displays with coordinates */
            updateInfoDisplay() {
                const degrees = this.currentAngle * 180 / Math.PI;
                const angleText = this.showDegrees 
                    ? `${degrees.toFixed(2)}°`
                    : `${this.currentAngle.toFixed(2)} rad (${degrees.toFixed(2)}°)`;
                document.getElementById('angle-display').textContent = angleText;
                document.getElementById('arc-length-display').textContent = 
                    `Arc Length: s = rθ (θ = ${this.currentAngle.toFixed(2)} rad)`;
                const x = Math.cos(this.currentAngle).toFixed(2);
                const y = Math.sin(this.currentAngle).toFixed(2);
                document.getElementById('point-coordinates').textContent = 
                    `Point: (x, y) = (${x}, ${y})`;

                let keyAngleText = '';
                for (const [angle, label] of Object.entries(RadianVisualizer.KEY_ANGLES)) {
                    if (Math.abs(this.currentAngle - angle) < 0.05) {
                        keyAngleText = `Key Angle: ${label}`;
                        break;
                    }
                }
                const tooltip = document.getElementById('key-angle-tooltip');
                tooltip.textContent = keyAngleText;
                tooltip.style.display = keyAngleText ? 'block' : 'none';
            }

            /** Draw the entire visualization */
            draw() {
                if (!this.ctx) return;
                try {
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    this.drawAxes();
                    this.drawCosmicCircle();
                    this.drawAngle();
                    this.drawRadius();
                    this.drawPositionMarker();
                    this.drawTrailParticles();
                    if (this.previewAngle !== null) {
                        this.drawPreviewArc();
                    }
                } catch (error) {
                    console.error('Draw error:', error);
                }
            }

            /** Draw x and y coordinate axes */
            drawAxes() {
                if (!this.ctx) return;
                this.ctx.beginPath();
                this.ctx.setLineDash([5, 5]);
                this.ctx.strokeStyle = `rgba(0, 200, 255, ${RadianVisualizer.AXIS_OPACITY})`;
                this.ctx.lineWidth = 1;

                // X-axis
                this.ctx.moveTo(this.center.x - this.radius * 1.2, this.center.y);
                this.ctx.lineTo(this.center.x + this.radius * 1.2, this.center.y);

                // Y-axis
                this.ctx.moveTo(this.center.x, this.center.y - this.radius * 1.2);
                this.ctx.lineTo(this.center.x, this.center.y + this.radius * 1.2);

                this.ctx.stroke();
                this.ctx.setLineDash([]);

                // Ticks at -1, 0, 1
                const ticks = [-1, 0, 1];
                ticks.forEach(t => {
                    if (t !== 0) { // Skip center to avoid overdraw
                        // X-axis ticks
                        this.ctx.beginPath();
                        const x = this.center.x + t * this.radius;
                        this.ctx.moveTo(x, this.center.y - RadianVisualizer.TICK_SIZE);
                        this.ctx.lineTo(x, this.center.y + RadianVisualizer.TICK_SIZE);
                        this.ctx.stroke();

                        // Y-axis ticks
                        this.ctx.beginPath();
                        const y = this.center.y - t * this.radius;
                        this.ctx.moveTo(this.center.x - RadianVisualizer.TICK_SIZE, y);
                        this.ctx.lineTo(this.center.x + RadianVisualizer.TICK_SIZE, y);
                        this.ctx.stroke();
                    }
                });
            }

            /** Draw the cosmic circle with dynamic effects */
            drawCosmicCircle() {
                if (!this.ctx) return;
                const glowOpacity = 0.2 + 0.1 * Math.sin(Date.now() * 0.001);
                const gradient = this.ctx.createRadialGradient(
                    this.center.x, this.center.y, this.radius * 0.9,
                    this.center.x, this.center.y, this.radius * 1.1
                );
                gradient.addColorStop(0, 'rgba(0, 100, 255, 0)');
                gradient.addColorStop(1, `rgba(0, 100, 255, ${glowOpacity})`);
                
                this.ctx.beginPath();
                this.ctx.arc(this.center.x, this.center.y, this.radius * 1.1, 0, Math.PI * 2);
                this.ctx.fillStyle = gradient;
                this.ctx.fill();
                
                this.ctx.beginPath();
                this.ctx.arc(this.center.x, this.center.y, this.radius, 0, Math.PI * 2);
                this.ctx.strokeStyle = 'rgba(0, 150, 255, 0.4)';
                this.ctx.lineWidth = 2;
                this.ctx.stroke();
                
                const centerSize = 4 + 1 * Math.sin(Date.now() * 0.005);
                this.ctx.beginPath();
                this.ctx.arc(this.center.x, this.center.y, centerSize, 0, Math.PI * 2);
                this.ctx.fillStyle = 'rgba(0, 200, 255, 0.9)';
                this.ctx.shadowBlur = 10;
                this.ctx.shadowColor = 'rgba(0, 200, 255, 0.9)';
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
            }

            /** Draw the angle arc with glow */
            drawAngle() {
                if (!this.ctx || this.currentAngle <= 0) return;
                let strokeStyle = 'rgba(0, 255, 255, 0.7)';
                let shadowColor = 'rgba(0, 255, 255, 0.5)';
                for (const [angle, label] of Object.entries(RadianVisualizer.KEY_ANGLES)) {
                    if (Math.abs(this.currentAngle - angle) < 0.05) {
                        strokeStyle = angle == 1 ? 'rgba(255, 100, 100, 0.7)' :
                                     angle == Math.PI / 2 ? 'rgba(100, 255, 100, 0.7)' :
                                     angle == Math.PI ? 'rgba(255, 255, 100, 0.7)' :
                                     'rgba(200, 100, 255, 0.7)';
                        shadowColor = angle == 1 ? 'rgba(255, 100, 100, 0.5)' :
                                     angle == Math.PI / 2 ? 'rgba(100, 255, 100, 0.5)' :
                                     angle == Math.PI ? 'rgba(255, 255, 100, 0.5)' :
                                     'rgba(200, 100, 255, 0.5)';
                        break;
                    }
                }
                
                this.ctx.beginPath();
                this.ctx.arc(this.center.x, this.center.y, this.radius, 0, this.currentAngle);
                this.ctx.strokeStyle = strokeStyle;
                this.ctx.lineWidth = 3;
                this.ctx.shadowBlur = 8;
                this.ctx.shadowColor = shadowColor;
                this.ctx.stroke();
                this.ctx.shadowBlur = 0;
            }

            /** Draw the radius line */
            drawRadius() {
                if (!this.ctx) return;
                const endX = this.center.x + this.radius * Math.cos(this.currentAngle);
                const endY = this.center.y - this.radius * Math.sin(this.currentAngle);
                
                this.ctx.beginPath();
                this.ctx.moveTo(this.center.x, this.center.y);
                this.ctx.lineTo(endX, endY);
                this.ctx.strokeStyle = 'rgba(0, 200, 255, 0.5)';
                this.ctx.lineWidth = 1;
                this.ctx.stroke();
            }

            /** Draw the position marker with enhanced particles */
            drawPositionMarker() {
                if (!this.ctx || this.currentAngle <= 0) return;
                const x = this.center.x + this.radius * Math.cos(this.currentAngle);
                const y = this.center.y - this.radius * Math.sin(this.currentAngle);
                
                if (Math.abs(this.targetAngle - this.currentAngle) > 0.01) {
                    this.trailParticles.push({
                        x, y,
                        size: Math.random() * 5 + 2,
                        opacity: 1,
                        life: 50,
                        color: `rgba(${255 - Math.random() * 50}, ${100 - Math.random() * 50}, 100, 1)`
                    });
                    if (this.trailParticles.length > 20) {
                        this.trailParticles.shift();
                    }
                }
                
                const pulseSize = 6 + 2 * Math.sin(Date.now() * 0.01);
                this.ctx.beginPath();
                this.ctx.arc(x, y, pulseSize, 0, Math.PI * 2);
                this.ctx.fillStyle = 'rgba(255, 50, 50, 0.9)';
                this.ctx.shadowBlur = 15;
                this.ctx.shadowColor = 'rgba(255, 50, 50, 0.7)';
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
            }

            /** Draw trail particles */
            drawTrailParticles() {
                if (!this.ctx) return;
                for (let i = this.trailParticles.length - 1; i >= 0; i--) {
                    const p = this.trailParticles[i];
                    p.life -= 2;
                    p.opacity = p.life / 50;
                    p.size *= 0.98;
                    
                    if (p.life <= 0) {
                        this.trailParticles.splice(i, 1);
                        continue;
                    }
                    
                    this.ctx.beginPath();
                    this.ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    this.ctx.fillStyle = p.color.replace('1)', `${p.opacity})`);
                    this.ctx.fill();
                }
            }

            /** Draw preview arc during slider drag */
            drawPreviewArc() {
                if (!this.ctx || this.previewAngle <= 0) return;
                this.ctx.beginPath();
                this.ctx.arc(this.center.x, this.center.y, this.radius, 0, this.previewAngle);
                this.ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
                this.ctx.lineWidth = 2;
                this.ctx.stroke();
            }

            /** Start animation */
            animate() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
                this.lastFrameTime = performance.now();
                this.animateToAngle();
            }
        }

        // Initialize when loaded
        window.addEventListener('load', () => {
            const canvas = document.getElementById('radianCanvas');
            const visualizer = new RadianVisualizer(canvas);
            
            setTimeout(() => {
                visualizer.slider.value = 1;
                visualizer.slider.setAttribute('aria-valuenow', '1');
                visualizer.targetAngle = 1;
                visualizer.updateSliderDisplay();
                visualizer.animate();
            }, 500);
        });
    </script>
</body>
</html>